const char* g_hlsl_str =
{
 "struct vertexIn                        "
 "{                                      "
 " float4        pos : POSITION;         "
 " unsigned int2 uv  : TEXCOORD;         "
 "};                                     "
 "                                       "
 "struct vertexOut                       "
 "{                                      "
 " float4   pos : SV_POSITION;           "
 " float2   uv : TEXCOORD0;              "
 "};                                     "
 "                                       "
 "                                       "
 "Texture2D  txDiffuse   : register(t0); "
 "SamplerState samLinear : register(s0); "
 "                                       "
 "                                       "
 "cbuffer global                         "
 "{                                      "
 " float4 size;                          "
 " float4 color;                         "
 " float4 rect_in;                       "
 " float4 rect_out;                      "
 " float4 rotation;                      "
 "};                                     "
 "                                       "
 "vertexOut vs(vertexIn IN)              "
 "{                                      "
 " vertexOut OUT;                        "
 " float x = size.z;                     "
 " float y = size.w;                     "
 " float r = 3.14f / 180.0f*rotation.x;  "
 " float t = ((rect_out.z - rect_out.x) / size.z)*2.0f;  "
 " float d = (-(rect_out.w - rect_out.y) / size.w)*2.0f; "
 "                                       "
 " float2 pos;                           "
 " pos.x = IN.pos.x - 0.5f;              "
 " pos.y = IN.pos.y - 0.5f;              "
 " pos.x *= -(rect_out.x - rect_out.z)*2.0f / size.z;    "
 " pos.y *= -(rect_out.y - rect_out.w)*2.0f / size.w;    "
 "                                       "
 "                                       "
 " float2 r_pos;                         "
 " r_pos.x = pos.x*cos(-r) - pos.y*sin(-r)* (y / x);       "
 " r_pos.y = pos.y*cos(-r) + pos.x*sin(-r)* (x / y);       "
 "                                       "
 "                                       "
 " float2 s_pos;                         "
 " s_pos.x = r_pos.x - 0.5f * (rect_out.x - rect_out.z)*2.0f / size.z;   "
 " s_pos.y = r_pos.y - 0.5f * (rect_out.y - rect_out.w)*2.0f / size.w;   "
 "                                       "
 "                                       "
 " float2 t_pos;                         "
 " t_pos.x = s_pos.x - 1.0f + (rect_out.x*2.0f / x);     "
 " t_pos.y = -s_pos.y + 1.0f + (-rect_out.y*2.0f / y);   "
 "                                       "
 "                                       "
 " float f[4] = { rect_in.x / size.x , rect_in.z / size.x , rect_in.y / size.y , rect_in.w / size.y };   "
 " float2 uv = (float2)0.0f;             "
 " uv.x = f[IN.uv.x];                    "
 " uv.y = f[IN.uv.y];                    "
 "                                       "
 " OUT.pos = IN.pos;                     "
 " OUT.pos.xy = t_pos.xy;                "
 " OUT.uv = uv;                          "
 " return OUT;                           "
 "}                                      "
 "                                       "
 "float4 ps(vertexOut IN) : SV_Target    "
 "{                                      "
 " float4  col = (float4)0.0f;           "
 " float4  tex = (float4)0.0f;           "
 "                                       "
 " if(size.x == 0.0f)                    "
 " {                                     "
 "  col = color;                          "
 " }                                     "
 " else                                  "
 " {                                     "
 "  tex = txDiffuse.Sample(samLinear, IN.uv);  "
 "  col = tex*color;                     "
 " }                                     "
 " return col;                           "
 "}                                      "

};




